# 注解

## @Configuration

从Spring3.0，@Configuration用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。

**注意**：@Configuration注解的配置类有如下要求：

1. @Configuration不可以是final类型；
2. @Configuration不可以是匿名类；
3. 嵌套的configuration必须是静态类。

## @Value

该注解的作用是将我们配置文件的属性读出来，有**@Value(“${}”)**和**@Value(“#{}”)**两种方式

## **@Resource**

@Resource主要做依赖注入的，从容器中自动获取bean，和@Autowired用法相似，@Resource按byName自动注入

## @Autowired

@Autowired注释，按by type自动注入，一般用在Service前面，Dao前面，Config前面。它可以对类成员变量、方法及构造函数进行标注，让 spring 完成 bean 自动装配的工作

## @Controller

在对应的方法上，视图解析器可以解析return 的jsp,html页面，并且跳转到相应页面

若返回json等内容到页面，则需要加@ResponseBody注解

## @ResponseBody

将java对象转为json格式的数据

## @RestController

相当于@Controller+@ResponseBody两个注解的结合，返回json数据不需要在方法前面加@ResponseBody注解了，但使用@RestController这个注解，就不能返回jsp,html页面，视图解析器无法解析jsp,html页面

## @RequestMapping

通过它来指定控制器可以处理哪些URL请求，相当于Servlet中在web.xml中配置

Spring的复杂性不是来自于它处理的对象，而是来自于自身，不断演进发展的Spring会带来时间维度上复杂性，比如SpringMVC以前版本的*@RequestMapping*，到了新版本被下面新注释替代，相当于增加的选项：

- *@GetMapping*
- *@PostMapping*
- *@PutMapping*
- *@DeleteMapping*
- *@PatchMapping*

从命名约定我们可以看到每个注释都是为了处理各自的传入请求方法类型，即*@GetMapping*用于处理请求方法的*GET*类型，*@ PostMapping*用于处理请求方法的*POST*类型等。

## @Mapper

使用@mapper后，不需要在spring配置中设置扫描地址，通过mapper.xml里面的namespace属性对应相关的mapper类，spring将动态的生成Bean后注入到ServiceImpl中

## @MapperScan

指定要变成实现类的接口所在的包，然后包下面的所有接口在编译之后都会生成相应的实现类
 添加位置：是在Springboot启动类上面添加

例如：添加@MapperScan(“com.winter.dao”)注解以后，com.winter.dao包下面的接口类，在编译之后都会生成相应的实现类

## @Repository

它用于将数据访问层 (DAO 层 ) 的类标识为 Spring Bean。具体只需将该注解标注在 DAO类上即可。同时，为了让 Spring 能够扫描类路径中的类并识别出 @Repository 注解，需要在 XML 配置文件中启用Bean 的自动扫描功能

## @Data

提高代码的简洁，使用这个注解可以省去代码中大量的get()、 set()、 toString()等方法。要使用 @Data 注解要先引入lombok

## @ToString

节省了ToString方法，重写ToString方法

## @AllArgsConstructor

它是lombok中的注解,作用在类上使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数

## @NoArgsConstructor

注解在类上，为类提供一个无参的构造方法

## @Accessors

@Accessors用于配置getter和setter方法的生成结果，下面介绍三个属性

fluent：中文含义是流畅的，设置为true，则getter和setter方法的方法名都是基础属性名，且setter方法返回当前对象

chain：的中文含义是链式的，设置为true，则setter方法返回当前对象

prefix：的中文含义是前缀，用于生成getter和setter方法的字段名会忽视指定前缀（遵守驼峰命名）

## @Component

把普通pojo实例化到spring容器中，相当于配置文件中的 <bean id="" class=""/>
泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类

## @Service

将service层对象注入到spring容器中，和xml配置文件中的标签作用一样

## @SpringBootApplication

用来标注在主程序的，表明他是一个springboot项目，是Sprnig Boot项目的核心注解，目的是开启自动配置

## @RequestParam

将请求参数绑定到你控制器的方法参数上（是springmvc中接收普通参数的注解）

语法：@RequestParam(value=”参数名”,required=”true/false”,defaultValue=””)

value：参数名

required：是否包含该参数，默认为true，表示该请求路径中必须包含该参数，如果不包含就报错。

defaultValue：默认参数值，如果设置了该值，required=true将失效，自动为false,如果没有传该参数，就使用默认值
